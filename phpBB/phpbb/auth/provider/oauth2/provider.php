<?php

namespace phpbb\auth\provider\oauth2;

use League\OAuth2\Client\Provider\AbstractProvider;
use League\OAuth2\Client\Provider\Exception\IdentityProviderException;
use League\OAuth2\Client\Provider\ResourceOwnerInterface;
use phpbb\auth\provider\base;
use phpbb\auth\provider\db;
use phpbb\auth\provider\oauth2\wrapper\wrapper_interface;
use phpbb\di\service_collection;
use phpbb\request\request_interface;

class provider extends base
{

	public function __construct(protected db $auth_db,
								protected request_interface $request,
								protected token_storage $token_storage,
								protected service_collection $wrapper_services,
								protected string $php_ext)
	{
		// TODO: Implement __construct() method.
	}

	public function init()
	{
		parent::init(); // TODO: Change the autogenerated stub
	}

	public function login($username, $password)
	{
		if (!$this->request->is_set('oauth_service'))
		{
			return $this->auth_db->login($username, $password);
		}

		// Request the name of the OAuth service
		$service_name = $this->get_service_name($this->request->variable('oauth_service', ''));

		if (!$service_name)
		{
			return [
				'status'		=> LOGIN_ERROR_EXTERNAL_AUTH,
				'error_msg'		=> 'LOGIN_ERROR_OAUTH_SERVICE_DOES_NOT_EXIST',
				'user_row'		=> ['user_id' => ANONYMOUS],
			];
		}

		$provider = $this->get_provider($service_name);
		if ($this->request->is_set('code', request_interface::GET))
		{
			return $this->perform_authentication($provider, $service_name);
		}
		else
		{
			$this->set_redirect($provider, $service_name);
		}
	}

	/**
	 * Returns the service name for an OAuth provider name.
	 *
	 * @param string $service_name		The OAuth provider name
	 * @return string					The service name
	 */
	protected function get_service_name(string $service_name): string
	{
		foreach ($this->wrapper_services as $name => $service)
		{
			if ($name === $service_name)
			{
				return $name;
			}

			if ('auth.provider.oauth2.wrapper.' . utf8_strtolower($service_name) === $name)
			{
				return 'auth.provider.oauth2.wrapper.' . utf8_strtolower($service_name);
			}
		}

		return '';
	}

	/**
	 * Retrieves the provider name from the given service name.
	 *
	 * @param string $service_name The service name to retrieve the provider name from.
	 * @return string The provider name.
	 */
	protected function get_provider_name(string $service_name): string
	{
		return str_replace('auth.provider.oauth2.wrapper.', '', $service_name);
	}

	/**
	 * Retrieves the provider for a given service name.
	 *
	 * @param string $service_name The name of the service.
	 * @return AbstractProvider The provider for the service.
	 */

	protected function get_provider(string $service_name): AbstractProvider
	{
		/** @var wrapper_interface $wrapper */
		$wrapper = $this->wrapper_services->offsetGet($service_name);

		$options = [
			'redirectUri'	=> generate_board_url() . '/ucp.' . $this->php_ext . '?mode=login&login=external&oauth_service=' . $this->get_provider_name($service_name),
		];

		return $wrapper->get_provider($options);
	}

	/**
	 * Set the redirect for the given provider
	 *
	 * @param AbstractProvider $provider The provider object.
	 */
	protected function set_redirect(AbstractProvider $provider, string $service_name): never
	{
		// Fetch the authorization URL from the provider; this returns the
		// urlAuthorize option and generates and applies any necessary parameters
		// (e.g. state).
		$authorizationUrl = $provider->getAuthorizationUrl();

		$this->token_storage->store_state($service_name, $provider->getState());

		redirect($authorizationUrl, false, true);

		exit; // Will not be reached due to redirect
	}

	protected function perform_authentication(AbstractProvider $provider, string $service_name): array
	{
		try
		{
			// Try to get an access token using the authorization code grant.
			$access_token = $provider->getAccessToken('authorization_code', [
				'code' => $this->request->variable('code', ''),
			]);

			$this->token_storage->store_authentication_token($service_name, $access_token);

			$resource_owner = $provider->getResourceOwner($access_token);

		}
		catch (IdentityProviderException $e)
		{
			return [
				'status'		=> LOGIN_ERROR_EXTERNAL_AUTH,
				'error_msg'		=> $e->getMessage(),
				'user_row'		=> ['user_id' => ANONYMOUS],
			];
		}

		return $this->setup_account_link($resource_owner, $service_name);
	}

	protected function setup_account_link(ResourceOwnerInterface $resource_owner, string $service_name): array
	{
		/**
		 * Check to see if this provider is already associated with an account.
		 *
		 * Enforcing a data type to make sure it are strings and not integers,
		 * so values are quoted in the SQL WHERE statement.
		 */
		$data = [
			'provider'			=> $service_name,
			'oauth_provider_id'	=> (string) $resource_owner->getId()
		];
		/*

		$sql = 'SELECT user_id
				FROM ' . $this->oauth_account_table . '
				WHERE ' . $this->db->sql_build_array('SELECT', $data);
		$result = $this->db->sql_query($sql);
		$row = $this->db->sql_fetchrow($result);
		$this->db->sql_freeresult($result);
		*/
		$redirect_data = array(
			'auth_provider'				=> 'oauth',
			'login_link_oauth_service'	=> $service_name,
		);

		/**
		 * Event is triggered before check if provider is already associated with an account
		 *
		 * @event core.oauth_login_after_check_if_provider_id_has_match
		 * @var array				row				User row
		 * @var array				data			Provider data
		 * @var	array				redirect_data	Data to be appended to the redirect url
		 * @var ServiceInterface	service			OAuth service
		 * @since 3.2.3-RC1
		 * @changed 3.2.6-RC1						Added redirect_data
		 * @psalm-var string[] $vars
		 */
		/*
		$vars = [
			'row',
			'data',
			'redirect_data',
			'service',
		];
		extract($this->dispatcher->trigger_event('core.oauth_login_after_check_if_provider_id_has_match', compact($vars)));
		*/

		if (true/* !$row */)
		{
			// The user does not yet exist, ask to link or create profile
			return [
				'status'		=> LOGIN_SUCCESS_LINK_PROFILE,
				'error_msg'		=> 'LOGIN_OAUTH_ACCOUNT_NOT_LINKED',
				'user_row'		=> [],
				'redirect_data'	=> $redirect_data,
			];
		}
		/*

		// Retrieve the user's account
		$sql = 'SELECT user_id, username, user_password, user_passchg, user_email, user_ip, user_type, user_login_attempts
				FROM ' . $this->users_table . '
				WHERE user_id = ' . (int) $row['user_id'];
		$result = $this->db->sql_query($sql);
		$row = $this->db->sql_fetchrow($result);
		$this->db->sql_freeresult($result);

		if (!$row)
		{
			return [
				'status'		=> LOGIN_ERROR_EXTERNAL_AUTH,
				'error_msg'		=> 'AUTH_PROVIDER_OAUTH_ERROR_INVALID_ENTRY',
				'user_row'		=> ['user_id' => ANONYMOUS],
			];
		}
		*/

		/**
		 * Check if the user is banned.
		 * The fourth parameter (return) has to be true, otherwise the OAuth login is still called and
		 * an uncaught exception is thrown as there is no token stored in the database.
		 */
		/*
		$ban = $this->user->check_ban($row['user_id'], $row['user_ip'], $row['user_email'], true);

		if (!empty($ban))
		{
			$till_date = !empty($ban['ban_end']) ? $this->user->format_date($ban['ban_end']) : '';
			$message = !empty($ban['ban_end']) ? 'BOARD_BAN_TIME' : 'BOARD_BAN_PERM';

			$contact_link = phpbb_get_board_contact_link($this->config, $this->root_path, $this->php_ext);

			$message = $this->language->lang($message, $till_date, '<a href="' . $contact_link . '">', '</a>');
			$message .= !empty($ban['ban_give_reason']) ? '<br /><br />' . $this->language->lang('BOARD_BAN_REASON', $ban['ban_give_reason']) : '';
			$message .= !empty($ban['ban_triggered_by']) ? '<br /><br /><em>' . $this->language->lang('BAN_TRIGGERED_BY_' . utf8_strtoupper($ban['ban_triggered_by'])) . '</em>' : '';

			return [
				'status'	=> LOGIN_BREAK,
				'error_msg'	=> $message,
				'user_row'	=> $row,
			];
		}

		// Update token storage to store the user_id
		$storage->set_user_id($row['user_id']);
		*/

		/**
		 * Event is triggered after user is successfully logged in via OAuth.
		 *
		 * @event core.auth_oauth_login_after
		 * @var array	row		User row
		 * @since 3.1.11-RC1
		 */
		/*
		$vars = [
			'row',
		];
		extract($this->dispatcher->trigger_event('core.auth_oauth_login_after', compact($vars)));

		// The user is now authenticated and can be logged in
		return [
			'status'		=> LOGIN_SUCCESS,
			'error_msg'		=> false,
			'user_row'		=> $row,
		];
		*/
	}

	/**
	 * {@inheritdoc}
	 */
	public function get_login_data()
	{
		$login_data = [
			'TEMPLATE_FILE'		=> 'login_body_oauth2.html',
			'BLOCK_VAR_NAME'	=> 'oauth2',
			'BLOCK_VARS'		=> [],
		];

		/** @var wrapper_interface $provider_wrapper */
		foreach ($this->wrapper_services as $service_name => $provider_wrapper)
		{
			if ($provider_wrapper->has_credentials())
			{
				$provider = $this->get_provider_name($service_name);
				$redirect_url = generate_board_url() . '/ucp.' . $this->php_ext . '?mode=login&login=external&oauth_service=' . $provider;

				$login_data['BLOCK_VARS'][$service_name] = [
					'REDIRECT_URL'	=> redirect($redirect_url, true),
					'SERVICE_NAME'	=> $provider_wrapper->get_name(),
					'ICON'			=> $provider_wrapper->get_icon(),
				];
			}
		}

		return $login_data;
	}
}
